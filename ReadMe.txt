ВИКОРИСТОВУВАВ: openjdk-23.
jar-file знаходиться в релізах: https://github.com/OleksandrHolopapa/Cryptographer.Oleksandr.Holopapa/releases/tag/release
ЯК ПРАЦЮЄ:

Запустити програму можна як з вхідними параметрами, так і без них. При запуску, в методі main створюється об'єкт класу
CLI, та викликається один з двох його конструкторів, залежно від наявності вхідних параметрів. 0 параметрів: вікно
програми міститиме лише одне заповнене поле для вибору команди. За замовчуванням вибрана команда ENCRYPT. Поле вибору
команди реалізовано у формі списку з трьома доступними варіантами: ENCRYPT, DECRYPT, BRUTE FORCE. Друге поле - поле для
вибору абсолютного шляху до початкового файлу. Його можна заповнити як вручну, так і просто обрати потрібний файл,
натиснувши на кнопку "...". В поле для ключа вводимо ключ. Щоб розпочати виконання команди, потрібно натиснути кнопку з
назвою цієї команди. Ліва текстова область заповниться вмістом вхідного файлу, після його зчитування. Права текстова область -
після виконання обраної команди. В праву текстову область передається текст не з файлу, а відразу змінений текст за допомогою
об'єкта класу FileWork, за допомогою методу getFinalText(). Чомусь новостворений файл з'являється у вікні середовища
розробки з затримкою до 10-15 секунд. Кнопка Clean очищає текстові області. Якщо через консоль передавати параметри, то
вікно програми запуститься з заповненими полями. Але якщо вказана команда некоректна, то в полі вибору команди буде ENCRYPT.
Після натискання на кнопку виконання, якщо шлях до файлу чи ключ некоректні/невказані з'явиться вікно з відповідним
повідомленням. Для BRUTE FORCE ключ не потрібний. При його знаходженні з'явиться вікно з його значенням. Також, в поле
keyValueTextField буде записано знайдений ключ.

З бібліотекою swing працюю лише два дні. Не зміг нормально розібратися з диспетчером компонування, тому писав без нього.
Всі елементи розміщав, задаючи координати та розміри вручну. Тому при зміні розмірів вікна програми, всі її елементи
залишаться на місцях та того ж розміру.

Клас Runner створює об'єкт класу FileWork. Виводить повідомлення зі значенням ключа для BRUTE FORCE. Обробляє Exceptions,
та виводить відповідні повідомлення.

Клас FileWork працює з файлом. Об'єкт FileWork отримує введені параметри, ініціалізує відповідні поля: command, source_file, key.
Поле destination_file ініціалізується за допомогою методу getDestinationFileName(String oldFileName, String fileStatus),
новий файл записується в ту саму директорію, звідки взятий вхідний файл. До імені отриманого файлу додається статус [ENCRYPTED],
[DECRYPTED] або [BRUTE_FORCE, KEY = key_value]. Значення key_value варіюється від 1 до 66 включно. Це пов'язано з тим, що
алфавіти використовуються циклічно. Їхня довжина 67 символів. Тому закодовані файли при ключах 2 та 68 будуть однаковими
(так само при ключах 100 і 33, -1 і 66, при 0 здвигу не буде, при 67 алфавіт зробить повне коло і т. д.).
Метод readAndWrite() читає файл в строку, ініціалізує глобальну змінну finalText та записує її в новий файл.

Команда BRUTE_FORCE: основну роботу робить метод int getKey(String text, AlgorithmOfCaesar algorithm). Він шукає
збіг символів: [','+' '] і ['.'+' ']. Такий алгоритм був показаний у відео до проєкту на платформі. Він непогано працює.
Але я використовую англійський та український алфавіти. При різній їхній довжині були проблеми з пошуком ключа,
що перевищував довжину довшого алфавіту. Наприклад, при кодуванні ключем 100 тексту, що містить англійські та українськи
слова, україський алфавіт пройде три повні оберти, і символи здвинуться на 1. Англійський алфавіт зробить 3 повні оберти,
і символи здвинуться на 22. Уже отримали різні ключі. Тому я доповнив ці алфавіти символами, довжина кожного 67 символів.
Режим BRUTE_FORCE спрацьовував як при додатних, так і при від'ємних ключах(20, 100, -200). Щоб BRUTE_FORCE спрацював,
потрібно, щоб в тексті було декілька речень, і хоча б одне містило кому.

Клас AlgorithmOfCaesar шифрує і дешифрує строки посимвольно за допомогою методу
char codingSymbolOfInitialTex(char symbolOfInitialTex, int key, String usedAlphabet).
Строка:
while(positionOfNewSymbolInAlphabet<0) positionOfNewSymbolInAlphabet = usedAlphabet.length()+positionOfNewSymbolInAlphabet;
забезпечує циклічний рух алфавітами вліво. Строка:
usedAlphabet.charAt(positionOfNewSymbolInAlphabet%usedAlphabet.length());
забезпечує циклічний рух алфавітами вправо.
Використовуються два алфавіти. Українські букви кодуються українськими буквами та пробілом. Англійськи - англійськими
та рештою символів. Цікаво, чи рахується це, як автоматичне розпізнавання алфавіту? Методи coding(String text, int key)
та decoding(String text, int key) повертають змінену строку, залежно від введеної команди.

Файл Sourse.txt містить текст англійською та українською. На ньому можна випробувати роботу програми.

ЩО ВИКОНАНО:
З технічного завдання виконані пункти: 1-9;
З додаткових завдань завдання: 1, 2(на ваш розсуд), 3, 4(але, оскільки використано не частотний аналіз,
то передача другого файлу непотрібна), 5;
