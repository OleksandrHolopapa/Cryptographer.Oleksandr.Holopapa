ВИКОРИСТОВУВАВ: openjdk-23.
jar-file знаходиться в релізах: https://github.com/OleksandrHolopapa/Cryptographer.Oleksandr.Holopapa/releases/tag/release
ЯК ПРАЦЮЄ:
При запуску, в методі main створюється об'єкт класу Runner, та викликається його метод run(String[] argsOfMain).
Задача метода run() аналізувати кількість вхідних параметрів(команда, шлях до файлу, ключ).
Якщо не було передано жодного параметра, то починається діалог з клієнтом, де йому пропонується самому їх ввести. Для цього
створюється об'єкт класу CLI. Викликається його метод getFileWorkWithArgs(), що за допомогою private-методів, створює об'єкт
класу FileWork. Клієнт вводить три параметри для команд ENCRYPT/DECRYPT та два для BRUTE_FORCE. В інших випадках отримаємо повідомлення
про неправильну кількість параметрів, і програма завершиться.

Два параметри:
Для команди BRUTE_FORCE потрібно два параметри(сама команда та шлях до файлу). При введенні третього параметру-ключа, він буде проігнорований.
Створюється об'єкт класу FileWork, замість ключа передається порожній рядок.
Інша кількість параметрів для даної команди виведе повідомлення про неправильну кількість параметрів, і програма завершиться.

Три параметри:
При введенні трьох параметрів програма відпрацює для всіх команд.

Будь-яка інша кількість параметрів поверне відповідне повідомлення, і програма завершиться.
Будь-яка інша команда, окрім трьох визначених, поверне повідомлення про неправильну команду, і програма завершиться.
Помилки при відкриванні-закриванні файлу виведуть відповідне повідомлення, і програма завершиться.
Якщо ключ не ціле число виведеться повідомлення про неправильно введений ключ, і програма завершиться.
В методі String getCommand(Scanner scanner) відбувається перевірка для NumberFormatException. Оскільки в класі Runner
відбувається вивід повідомлень на основі Exception, то для NumberFormatException виведеться повідомлення про невірний ключ,
а нам потрібно повідомлення про неправильну команду.

Клас FileWork працює з файлом. Об'єкт FileWork отримує введені параметри, ініціалізує відповідні поля: command, source_file, key.
Поле destination_file ініціалізується за допомогою методу getDestinationFileName(String oldFileName, String fileStatus), новий файл
записується в ту саму директорію, звідки взятий вхідний файл. До імені отриманого файлу додається статус [ENCRYPTED], [DECRYPTED]
або [BRUTE_FORCE, KEY = key_value]. Значення key_value варіюється від 1 до 66 включно. Це пов'язано з тим що алфавіти використовуються циклічно.
Їхня довжина 67 символів. Тому закодовані файли при ключах 2 та 68 будуть однаковими(так само при ключах 100 і 33, -1 і 66, при 0 здвигу не буде,
при 67 алфавіт зробить повне коло і т. д.).
Метод readAndWrite() читає файл в строку, перетворює її методами coding(String text, int key) та decoding(String text, int key) класу AlgorithmOfCaesar,
залежно від команди та записує в новий файл. (Думав розбити даний метод на декілька, але писати метод read, щоб викликати Files.readString
здалося зайвим, аналогічно і для окремого методу write).

Команда BRUTE_FORCE: основну роботу робить метод int getKey(String text, AlgorithmOfCaesar algorithm). Він шукає збіг символів: [','+' '] і ['.'+' '].
Такий алгоритм був показаний у відео до проєкту на платформі. Він непогано працює. Але я використовую англійський та український алфавіти.
При різній їхній довжині були проблеми з пошуком ключа, що перевищував довжину довшого алфавіту. Наприклад, при кодуванні ключем 100 тексту,
що містить англійські та українськи слова, україський алфавіт пройде три повні оберти, і символи здвинуться на 1. Англійський алфавіт
зробить 3 повні оберти, і символи здвинуться на 22. Уже отримали різні ключі. Тому я доповнив ці алфавіти символами, довжина кожного 67 символів.
Режим BRUTE_FORCE спрацьовував як при додатних, так і при від'ємних ключах(20, 100, -200). Щоб BRUTE_FORCE спрацював, потрібно,
щоб в тексті було декілька речень, і хоча б одне містило кому.

Клас AlgorithmOfCaesar шифрує і дешифрує строки посимвольно за допомогою методу char codingSymbolOfInitialTex(char symbolOfInitialTex, int key, String usedAlphabet).
Строка
while(positionOfNewSymbolInAlphabet<0) positionOfNewSymbolInAlphabet = usedAlphabet.length()+positionOfNewSymbolInAlphabet;
забезпечує циклічний рух алфавітами вліво. Строка
usedAlphabet.charAt(positionOfNewSymbolInAlphabet%usedAlphabet.length());
забезпечує циклічний рух алфавітами вправо.
Використовуються два алфавіти. Українські букви кодуються українськими буквами та пробілом. Англійськи - англійськими та рештою символів.
Цікаво, чи рахується це, як автоматичне розпізнавання алфавіту? Методи coding(String text, int key) та decoding(String text, int key)
повертають змінену строку, залежно від введеної команди.

Файл Sourse.txt містить текст англійською та українською. На ньому можна випробувати роботу програми.

ЩО ВИКОНАНО:
З технічного завдання виконані пункти: 1-9;
З додаткових завдань завдання: 1, 2(на ваш розсуд), 3, 4(але, оскільки використано не частотний аналіз, то передача другого файлу непотрібна);

ЩО НЕ ВИКОНАНО:
З додаткових завдань завдання 5.
