ЯК ПРАЦЮЄ:
При запуску, в методі main створюється об'єкт класу Runner, та викликається його метод run(String[] args).
Задача метода run() аналізувати кількість вхідних параметрів(команда, шлях до файлу, ключ).
Якщо не було передано жодного параметра, то починається діалог з клієнтом, де йому пропонується самому їх ввести. Для цього
створюється об'єкт класу CLI. Викликається його метод getFileWorkWithArgs(), що за допомогою private-методів, створює об'єкт
класу FileWork. Клієнт вводить три параметри для команд ENCRYPT/DECRYPT та два для BRUTE_FORCE. В інших випадках отримаємо повідомлення
про неправильну кількість параметрів, і програма завершиться.

Два параметри:
Для команди BRUTE_FORCE потрібно два параметри(сама команда та шлях до файлу). При введенні третього параметру-ключа, він буде проігнорований.
Створюється об'єкт класу FileWork, замість ключа передається порожній рядок.
Інша кількість параметрів для даної команди виведе повідомлення про неправильну кількість параметрів, і програма завершиться.

Три параметри:
При введенні трьох параметрів програма відпрацює для всіх команд.

Будь-яка інша кількість параметрів поверне відповідне повідомлення, і програма завершиться.
Будь-яка інша команда, окрім трьох визначених, поверне повідомлення про неправильну команду, і програма завершиться.
Помилки при відкритті файлу виведуть відповідне повідомлення, і програма завершиться.
Якщо ключ не ціле число виведеться повідомлення про неправильно введений ключ, і програма завершиться.

Клас FileWork працює з файлом. Об'єкт FileWork отримує введені параметри, ініціалізує відповідні поля: command, source_file, key.
Поле destination_file ініціалізується за допомогою методу getDestinationFileName(String oldFileName, String status), новий файл
записується в ту саму директорію, звідки взятий вхідний файл. До імені отриманого файлу додається позначка [ENCRYPTED], [DECRYPTED]
або [BRUTE_FORCE, KEY = key_value]. Значення key_value варіюється від 1 до 67. Це пов'язано з тим що алфавіти використовуються циклічно.
Їхня довжина 67 символів. Тому закодовані файли при ключах 2 та 68 будуть однаковими(так само при ключах 100 і 33, -1 і 66, і т. д.).
Метод readAndWrite() читає файл в строку, перетворює її методами coding(String text, int key) та decoding(String text, int key) класу AlgorithmOfCaesar,
залежно від команди та записує в новий файл. (Думав розбити даний метод на декілька, але писати метод read, щоб викликати Files.readString
здалося зайвим, аналогічно і для окремого методу write).

Команда BRUTE_FORCE: основну роботу робить метод getKey(String text, AlgorithmOfCaesar algorithm). Він шукає збіг символів: [','+' '] і ['.'+' '].
Такий алгоритм був показаний у відео до проєкту на платформі. Він непогано працює. Але я використовую англійський та український алфавіти.
При різній їхній довжині були проблеми з пошуком ключа, що перевищував довжину довшого алфавіту. Тому я доповнив ці алфавіти символами,
довжина кожного 67 символів. Режим BRUTE_FORCE спрацьовував як при додатних, так і при від'ємних ключах(20, 100, -200).
Щоб BRUTE_FORCE спрацював, потрібно, щоб в тексті було декілька речень, і хоча б одне містило кому.

Клас AlgorithmOfCaesar шифрує і дешифрує строки посимвольно за допомогою методу codingSymbol(char ch, int key, String alphabet).
Використовуються два алфавіти. Українські букви кодуються українськими буквами та пробілом. Англійськи - англійськими та рештою символів.
Цікаво, чи рахується це, як автоматичне розпізнавання алфавіту? Методи coding(String text, int key) та decoding(String text, int key)
повертають змінену строку, залежно від введеної команди.

Файл Sourse.txt містить текст англійською та українською. На ньому можна випробувати роботу програми.

ЩО ВИКОНАНО:
З технічного завдання виконані пункти: 1-9;
З додаткових завдань завдання: 1, 2(на ваш розсуд), 3, 4(але, оскільки використано не частотний аналіз, то передача другого файлу непотрібна);

ЩО НЕ ВИКОНАНО:
З додаткових завдань завдання 5, Але якщо час дозволить, то до 4.02 може бути виконано.
